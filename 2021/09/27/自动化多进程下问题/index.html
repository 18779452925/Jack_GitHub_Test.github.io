<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>自动化多进程下问题 | Jack博客</title><meta name="keywords" content="work,工作"><meta name="author" content="Jack,wj1994808305@163.com"><meta name="copyright" content="Jack"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="自动化痛点  异步接口需要定时获取结果【未想到最优解决方式】 运行速度慢 容错性差，维护性差 不能很好的兼容多进程方式运行 多进程下运行session块被重复运行，初始化代码被多次初始化覆盖删除，多个session的文件锁 多进程下api层单例所遇问题 多进程下token的设计 多进程下数据共享问题  解决： 1、运行速度慢，我们可以采用多进程方式下去执行自动化，有pytest提供的常用插件pyt">
<meta property="og:type" content="article">
<meta property="og:title" content="自动化多进程下问题">
<meta property="og:url" content="https://jackgithubtest.github.io/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="Jack博客">
<meta property="og:description" content="自动化痛点  异步接口需要定时获取结果【未想到最优解决方式】 运行速度慢 容错性差，维护性差 不能很好的兼容多进程方式运行 多进程下运行session块被重复运行，初始化代码被多次初始化覆盖删除，多个session的文件锁 多进程下api层单例所遇问题 多进程下token的设计 多进程下数据共享问题  解决： 1、运行速度慢，我们可以采用多进程方式下去执行自动化，有pytest提供的常用插件pyt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg">
<meta property="article:published_time" content="2021-09-27T03:53:30.000Z">
<meta property="article:modified_time" content="2021-09-30T03:24:12.879Z">
<meta property="article:author" content="Jack">
<meta property="article:tag" content="work,工作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg"><link rel="shortcut icon" href="/img/MyBlog.png"><link rel="canonical" href="https://jackgithubtest.github.io/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '自动化多进程下问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-30 11:24:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jack博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/48502122?s=60&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> Vuepress</span></a></div><div class="menus_item"><a class="site-page" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jack博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> Vuepress</span></a></div><div class="menus_item"><a class="site-page" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">自动化多进程下问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-27T03:53:30.000Z" title="发表于 2021-09-27 11:53:30">2021-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-30T03:24:12.879Z" title="更新于 2021-09-30 11:24:12">2021-09-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="自动化多进程下问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>自动化痛点</p>
<ul>
<li>异步接口需要定时获取结果【未想到最优解决方式】</li>
<li>运行速度慢</li>
<li>容错性差，维护性差</li>
<li>不能很好的兼容多进程方式运行</li>
<li>多进程下运行session块被重复运行，初始化代码被多次初始化覆盖删除，多个session的文件锁</li>
<li>多进程下api层单例所遇问题</li>
<li>多进程下token的设计</li>
<li>多进程下数据共享问题</li>
</ul>
<p>解决：</p>
<p>1、运行速度慢，我们可以采用多进程方式下去执行自动化，有pytest提供的常用插件pytest-xsdit 插件，插件用法就是一条命令这里就不过多解释了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -n <span class="number">2</span> <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>

<p>采用此插件就能很好的解决多进程吗？答案是肯定是不是的：相信大家都知道session是一个进程是一个会话，那多个进程相比是有多个会话了？我们来验证我们的想法</p>
<p>目录结构为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comm</span><br><span class="line">	__init__.py</span><br><span class="line">testcase</span><br><span class="line">	test_*.py</span><br><span class="line">export</span><br><span class="line">	allure</span><br><span class="line">	html</span><br><span class="line">conftest.py</span><br><span class="line">run.py</span><br></pre></td></tr></table></figure>

<p>conftest.py</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/93034_image-20210927143425947.png" alt="image-20210927143425947"></p>
<p>pytest-xdist自动分配了四个进程来执行我们的自动化，注：pytest-xdist的auto会根据电脑的内核自动分配进程【明明我的电脑是8核，明天就提刀去联想官方店，希望给我一个完美的解释】</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/36702_image-20210927143220236.png" alt="image-20210927143220236"></p>
<p>由此可见，我们session级别的conftest被执行多次，说明session确实会存在问题，那要如何解决呢？</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/70973_image-20210927144512429.png" alt="image-20210927144512429"></p>
<p>看到了pytest-xdist官方解决方案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> filelock <span class="keyword">import</span> FileLock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;session&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">session_data</span>(<span class="params">tmp_path_factory, worker_id</span>):</span></span><br><span class="line">    <span class="keyword">if</span> worker_id == <span class="string">&quot;master&quot;</span>:</span><br><span class="line">        <span class="comment"># not executing in with multiple workers, just produce the data and let</span></span><br><span class="line">        <span class="comment"># pytest&#x27;s fixture caching do its job</span></span><br><span class="line">        <span class="keyword">return</span> produce_expensive_data()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the temp directory shared by all workers</span></span><br><span class="line">    root_tmp_dir = tmp_path_factory.getbasetemp().parent</span><br><span class="line"></span><br><span class="line">    fn = root_tmp_dir / <span class="string">&quot;data.json&quot;</span></span><br><span class="line">    <span class="keyword">with</span> FileLock(<span class="built_in">str</span>(fn) + <span class="string">&quot;.lock&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span> fn.is_file():</span><br><span class="line">            data = json.loads(fn.read_text())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = produce_expensive_data()</span><br><span class="line">            fn.write_text(json.dumps(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>看到官方给的解决方案其实是采用FileLock文件锁的方式进行解决，亲测，完全可以解决此问题</p>
<p>2、第二种多进程方案multprocessing Pool</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/52247_image-20210927145749854.png" alt="image-20210927145749854"></p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/45210_image-20210927145740377.png" alt="image-20210927145740377"></p>
<p>自动化是按照模块进行多进程执行，有多少模块启动多少个进程</p>
<p>为什么要用apply_async呢？因为他是非阻塞异步的, 他不会等待子进程执行完毕, 主进程会继续执行, 他会根据系统调度来进行进程切换</p>
<p>有不懂的吗？</p>
<p>不懂的话自己去敲代码吧，算了解释一下吧，我们来看一个栗子【比较好吃的那种】</p>
<p>首先我们看一下apply()阻塞异步</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doIt</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Process num is : %s&quot;</span> % num)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;process  %s end&#x27;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mainProcess start&#x27;</span>)</span><br><span class="line">    <span class="comment"># 记录一下开始执行的时间</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 创建三个子进程</span></span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child start&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        pool.apply(doIt, [i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mainProcess done time:%s s&#x27;</span> % (time.time() - start_time))</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/67631_image-20210927151339788.png" alt="image-20210927151339788"></p>
<p><strong>执行结果</strong> 我们可以看到, 主进程开始执行之后, 创建的三个子进程也随即开始执行, 主进程被阻塞, 这里跟上一篇文章介绍的<code>join()</code> 很类似, 而且接下来三个子进程是一个接一个按顺序地执行, 等到子进程全部执行完毕之后, 主进程就会继续执行, 打印出最后一句,</p>
<p>接下来我们看看apply_asyn()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doIt</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Process num is : %s&quot;</span> % num)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;process  %s end&#x27;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mainProcess start&#x27;</span>)</span><br><span class="line">    <span class="comment"># 记录一下开始执行的时间</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 创建三个子进程</span></span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child start&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        pool.apply_async(doIt, [i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mainProcess done time:%s s&#x27;</span> % (time.time() - start_time))</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/21256_image-20210927151549546.png" alt="image-20210927151549546"></p>
<p>OMG发生了什么，怎么之有一个主进程执行了？我的子进程呢？</p>
<p>我们来看看运行结果 , 可以看出来, 截图的第一句是上一个程序的执行消耗时间, 最后一句是使用<strong>apply_async()</strong> 所消耗的时间, 在这里, 主进程没有被阻塞, 验证了他是非阻塞的, 子进程没有执行, 验证了他是根据系统调度完成的, 为什么会这样呢?<br>原因是, 进程的切换时操作系统控制的, 我们首先运行的是主进程, 而CPU运行得又很快, 快到还没等系统调度到子线程, 主线程就已经运行完毕了, 并且退出程序. 所以子进程就没有运行了.</p>
<p>那我 调用了apply_async() 是不是就不能运行子进程了吗？ 肯定可以呀!!小老弟,想啥呢??</p>
<p>还记得**join()**告诉主进程老子要运行子进程就好呀, 还记得 join()的作用吗, 我们从上一篇介绍join()的文章可以知道他可以阻塞主进程, 等待所有子进程结束之后再运行, 我们在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;mainProcess done time:%s s&#x27; % (time.time() - start_time))</span><br></pre></td></tr></table></figure>

<p> 执行之前加入两句代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure>

<p>我们先要 close()一下子进程, 而且要先在 join() 前运行它,不逼逼赖赖，上代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doIt</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Process num is : %s&quot;</span> % num)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;process  %s end&#x27;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mainProcess start&#x27;</span>)</span><br><span class="line">    <span class="comment"># 记录一下开始执行的时间</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 创建三个子进程</span></span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child start&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        pool.apply_async(doIt, [i])</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mainProcess done time:%s s&#x27;</span> % (time.time() - start_time))</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/13250_image-20210927152537833.png" alt="image-20210927152537833"></p>
<p>这是什么速度，这也太快了，比**apply()**快了六倍？</p>
<p>我们看看加入这两句的运行结果, 首先我们可以看到即使是使用了非阻塞主进程的apply_async() 也能让子进程运行了, 在这里子进程按顺序交替运行了,<br>CPU在执行第一个子进程的时候, 还没等第一个子进程结束, 系统调度到了按顺序调度到了第二个子进程, 以此类推, 一直调度运行子进程, 一个接一个地结束子进程的运行, 最后运行主进程, 而且我们可以看到使用apply_async()的执行效力会更高, 你看一下他们各自执行结果最后一句的执行消耗时间就知道了, 这也是官方推荐我们使用apply_async()的主要原因吧</p>
<h4 id="还有一个非常重要的原因win上multprocessing和linux下的multprocessing的区别-相当于说为什么windows下需要freeze-support"><a href="#还有一个非常重要的原因win上multprocessing和linux下的multprocessing的区别-相当于说为什么windows下需要freeze-support" class="headerlink" title="还有一个非常重要的原因win上multprocessing和linux下的multprocessing的区别,相当于说为什么windows下需要freeze_support()"></a>还有一个非常重要的原因win上multprocessing和linux下的multprocessing的区别,相当于说为什么windows下需要freeze_support()</h4><p>Windows下面的multiprocessing跟Linux下面略有不同，Linux下面的multiprocessing基于fork，fork之后所有的本地变量都复制一份，因此可以使用任意的全局变量；<br>在Windows下面，多进程是通过启动新进程完成的，所有的全局变量都是重新初始化的，在运行过程中动态生成、修改过的全局变量是不能使用的。</p>
<p>multiprocessing内部使用pickling传递map的参数到不同的进程，当传递一个函数或类时，pickling将函数或者类用所在模块+函数/类名的方式表示，<br>如果对端的Python进程无法在对应的模块中找到相应的函数或者类，就会出错。<br>当你在Interactive Console当中创建函数的时候，这个函数是动态添加到__main__模块中的，在重新启动的新进程当中不存在，所以会出错。<br>当不在Console中，而是在独立Python文件中运行时，你会遇到另一个问题：由于你下面调用multiprocessing的代码没有保护，<br>在新进程加载这个模块的时候会重新执行这段代码，创建出新的multiprocessing池，无限调用下去。</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/34716_image-20210927153035952.png" alt="image-20210927153035952"></p>
<h5 id="好了扯了一大堆没有用的言归正传"><a href="#好了扯了一大堆没有用的言归正传" class="headerlink" title="好了扯了一大堆没有用的言归正传"></a>好了扯了一大堆没有用的言归正传</h5><p>那我们自己实现的多进程是不是也会有conftest的session问题呢？答案是肯定的，当然有了怎么会没有，自己去按照思路去实现一下吧</p>
<p>那既然官方解释是说通过FileLock来实现，那我们是不是也可以自己实现一个FileLock呢？最笨方法的那种，话不多说，说干就干</p>
<p><strong>conftest.py修改为</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>():</span></span><br><span class="line">    logger.add(<span class="string">&quot;aa.log&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;我是一个fixture，session级别的&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;session&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_print</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    call_name = inspect.stack()[<span class="number">1</span>].function</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;FileLock.lock&quot;</span>, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">if</span> call_name <span class="keyword">in</span> f.read():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f.write(call_name)</span><br><span class="line">            request.addfinalizer(log)</span><br><span class="line">            <span class="comment"># log()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> filelock <span class="keyword">import</span> FileLock</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;session&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">tmp_path_factory, worker_id</span>):</span></span><br><span class="line">    <span class="comment"># 如果是单机运行 则运行这里的代码块【不可删除、修改】</span></span><br><span class="line">    <span class="keyword">if</span> worker_id == <span class="string">&quot;master&quot;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        【自定义代码块】</span></span><br><span class="line"><span class="string">        这里就写你要本身应该要做的操作，比如：登录请求、新增数据、清空数据库历史数据等等</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        token = <span class="built_in">str</span>(random())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fixture:请求登录接口，获取token&quot;</span>, token)</span><br><span class="line">        os.environ[<span class="string">&#x27;token&#x27;</span>] = token</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果测试用例有需要，可以返回对应的数据，比如 token</span></span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是分布式运行</span></span><br><span class="line">    <span class="comment"># 获取所有子节点共享的临时目录，无需修改【不可删除、修改】</span></span><br><span class="line">    root_tmp_dir = tmp_path_factory.getbasetemp().parent</span><br><span class="line">    <span class="comment"># 【不可删除、修改】</span></span><br><span class="line">    fn = root_tmp_dir / <span class="string">&quot;data.json&quot;</span></span><br><span class="line">    <span class="comment"># 【不可删除、修改】</span></span><br><span class="line">    <span class="keyword">with</span> FileLock(<span class="built_in">str</span>(fn) + <span class="string">&quot;.lock&quot;</span>):</span><br><span class="line">        <span class="comment"># 【不可删除、修改】</span></span><br><span class="line">        <span class="keyword">if</span> fn.is_file():</span><br><span class="line">            <span class="comment"># 缓存文件中读取数据，像登录操作的话就是 token 【不可删除、修改】</span></span><br><span class="line">            token = json.loads(fn.read_text())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;读取缓存文件，token 是<span class="subst">&#123;token&#125;</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            【自定义代码块】</span></span><br><span class="line"><span class="string">            跟上面 if 的代码块一样就行</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            token = <span class="built_in">str</span>(random())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;fixture:请求登录接口，获取token&quot;</span>, token)</span><br><span class="line">            <span class="comment"># 【不可删除、修改】</span></span><br><span class="line">            fn.write_text(json.dumps(token))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;首次执行，token 是<span class="subst">&#123;token&#125;</span> &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最好将后续需要保留的数据存在某个地方，比如这里是 os 的环境变量</span></span><br><span class="line">        os.environ[<span class="string">&#x27;token&#x27;</span>] = token</span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure>

<p>main.py修改为：</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/84579_image-20210927154156807.png" alt="image-20210927154308215"></p>
<p>结果：意外的惊喜，session只运行了一次</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/74105_image-20210927154802299.png" alt="image-20210927154802299"></p>
<p>注：我们只需要限制pytest的hook函数执行conftest的session，千万不能限制自定义的函数去调用session，否在会出现异常</p>
<h4 id="session问题二：如果我有多个session呢？你看这代码，得到pytest的hook都是call-fixture-func啊这要怎么搞？"><a href="#session问题二：如果我有多个session呢？你看这代码，得到pytest的hook都是call-fixture-func啊这要怎么搞？" class="headerlink" title="session问题二：如果我有多个session呢？你看这代码，得到pytest的hook都是call_fixture_func啊这要怎么搞？"></a>session问题二：如果我有多个session呢？你看这代码，得到pytest的hook都是call_fixture_func啊这要怎么搞？</h4><p>call_fixture_limit.py限制一下就好了啊，<strong>注：采用a+方式去写入文件的时候，需要调整指针</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_limit</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;限制多进程下fixture重复调用&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    call_name = inspect.stack()[<span class="number">1</span>].function</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;FileLock.lock&quot;</span>, <span class="string">&quot;a+&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line">        CALL_LIST = f.read().split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> call_name <span class="keyword">in</span> CALL_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f.seek(<span class="number">2</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;<span class="subst">&#123;call_name&#125;</span>,&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/49993_image-20210927173555822.png" alt="image-20210927173555822"></p>
<h4 id="问题三：多进程下执行失败会出现Cache问题，如何解决呢？不要慌，不是在报错就是在报错的路上"><a href="#问题三：多进程下执行失败会出现Cache问题，如何解决呢？不要慌，不是在报错就是在报错的路上" class="headerlink" title="问题三：多进程下执行失败会出现Cache问题，如何解决呢？不要慌，不是在报错就是在报错的路上"></a>问题三：多进程下执行失败会出现Cache问题，如何解决呢？不要慌，不是在报错就是在报错的路上</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">index</span>):</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    pytest.main([<span class="string">&quot;-v&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;index&#125;</span>&quot;</span>, <span class="string">&quot;--cache-clear&quot;</span>, <span class="string">&quot;--alluredir=reports/allure&quot;</span>])</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>官方提供了专门的清除缓存的命令，是不是很银杏，但是用了这个命令又有问题了，有人就问了，这会有什么问题，怎么那么多问题，是的不要慌</p>
<p>采用了–cache-clear后呢会出现–lf命令的问题，因为lf失败重跑他是在缓存中去收集的，现在你把我缓存清掉了我怎么跑是吧，就很头疼了，所以呢可以提供一种解决思路，那就是手动去控制是否需要清除，如果不重跑呢？就清除，如果重跑呢？就不清除了，当然了有更好的解决方案可以提供一下给我</p>
<h4 id="问题四：多进程下多个session级别的fixtures文件之间互相调用问题，都说了不是在报错就是在报错的路上"><a href="#问题四：多进程下多个session级别的fixtures文件之间互相调用问题，都说了不是在报错就是在报错的路上" class="headerlink" title="问题四：多进程下多个session级别的fixtures文件之间互相调用问题，都说了不是在报错就是在报错的路上"></a>问题四：多进程下多个session级别的fixtures文件之间互相调用问题，都说了不是在报错就是在报错的路上</h4><p>问题：多个session级别的fixtures下会存在拿不到已经调用的fixtures文件的result，导致了获取不到值直接报错</p>
<p>解决方案：可以采用os.envircon来进行数据共享，记住，os.envircon只能设置字符串，一定要进行解析</p>
<h4 id="问题五：多进程下数据共享问题，会导致数据共享反射无法生效"><a href="#问题五：多进程下数据共享问题，会导致数据共享反射无法生效" class="headerlink" title="问题五：多进程下数据共享问题，会导致数据共享反射无法生效"></a>问题五：多进程下数据共享问题，会导致数据共享反射无法生效</h4><p>问题：参数化反射无法生效</p>
<p>解决方案：</p>
<p>可以写入整个系统的环境变量，例如os.environ[key]=value</p>
<p>思路就是重写object对象和metaclass元类的__setattr__魔术方法和__getattribute__方法</p>
<p>话不多说，完整代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamsPoolMetaClass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = <span class="built_in">super</span>().__getattribute__(item)</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, RecursionError) <span class="keyword">as</span> AE:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = <span class="built_in">eval</span>(os.environ.get(item.upper()))</span><br><span class="line">            <span class="keyword">except</span> (SyntaxError, TypeError) <span class="keyword">as</span> SE:</span><br><span class="line">                result = os.environ.get(item.upper())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__setattr__(key, value)</span><br><span class="line">        os.environ[key] = <span class="built_in">str</span>(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestParamsPool</span>(<span class="params">metaclass=ParamsPoolMetaClass</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = <span class="built_in">super</span>().__getattribute__(item)</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, RecursionError) <span class="keyword">as</span> AE:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = <span class="built_in">eval</span>(os.environ.get(item.upper()))</span><br><span class="line">            <span class="keyword">except</span> (SyntaxError, TypeError) <span class="keyword">as</span> SE:</span><br><span class="line">                result = os.environ.get(item.upper())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key: <span class="built_in">str</span>, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__setattr__(key, value)</span><br><span class="line">        os.environ[key.upper()] = <span class="built_in">str</span>(value)</span><br></pre></td></tr></table></figure>



<h2 id="多进程下API层单例问题"><a href="#多进程下API层单例问题" class="headerlink" title="多进程下API层单例问题"></a>多进程下API层单例问题</h2><p>疑问：不就是多进程吗？我直接一个multprocessing.Pool()一顿操作就好了，不就是把我的代码给不同得人一起跑吗？还会有那么多花里胡哨的问题？你搁这搁这搁这呢？</p>
<p>如你所愿啊，多进程下单例确实会有问题，虽然是单例，但是在多进程下单例是无法挡住的，会重新申请开辟地址并且返回对象，啊这么神奇</p>
<p>那么如何解决呢？当然是加锁了，铐起来，叉出去，获取了枷锁是不是就跑不了了。【又不是人人都是武松，只是想不想的问题】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronized</span>(<span class="params">func</span>):</span></span><br><span class="line">    func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">with</span> func.__lock__:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lock_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    isstance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls.isstance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.isstance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.isstance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">id</span>(self))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        p.apply_async(Singleton().printf)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>运行结果：发现id都一样，是不是就实现了单例，这玩意竟然那么神奇</p>
<p><img src="https://gitee.com/Jack_Gitee_Code/Ptoho_Iamge/raw/master/image/2021/09/27/55784_image-20210927161824853.png" alt="image-20210927161824853"></p>
<h2 id="3、多进程下Token的设计"><a href="#3、多进程下Token的设计" class="headerlink" title="3、多进程下Token的设计"></a>3、多进程下Token的设计</h2><p>还是可以基于单例的思想进行设计Token，Token类去继承单例类，实例化一个Token对象，这样在整个过程采用的Token都是相同不会出现Token问题</p>
<h2 id="4、用例执行过慢，维护性差"><a href="#4、用例执行过慢，维护性差" class="headerlink" title="4、用例执行过慢，维护性差"></a>4、用例执行过慢，维护性差</h2><h4 id="疑问：为什么要选择多进程，为什么不选择多线程呢？是不是大家都有这种疑问"><a href="#疑问：为什么要选择多进程，为什么不选择多线程呢？是不是大家都有这种疑问" class="headerlink" title="疑问：为什么要选择多进程，为什么不选择多线程呢？是不是大家都有这种疑问"></a>疑问：为什么要选择多进程，为什么不选择多线程呢？是不是大家都有这种疑问</h4><p>其实多进程和多线程都可以，问题是，多线程的bug无法解决啊，所以曲线救国，那就用高资源来换取bug吧</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wj1994808305@163.com">Jack</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jackgithubtest.github.io/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/">https://jackgithubtest.github.io/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jackgithubtest.github.io" target="_blank">Jack博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/work-%E5%B7%A5%E4%BD%9C/">work,工作</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/30/%E8%AF%AD%E9%9B%80%E9%85%8D%E7%BD%AE%E9%92%89%E9%92%89%E5%92%8C%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1webhook/"><img class="prev-cover" src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">语雀配置钉钉和企业微信webhook</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"><img class="next-cover" src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据库乐观锁和悲观锁</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/48502122?s=60&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jack</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jackgithubtest"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jackgithubtest" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1994808305" target="_blank" title="qq"><i class="fa fa-qq"></i></a><a class="social-icon" href="mailto:wj1994808305@163.com" target="_blank" title=""><i class="fa fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">每天成长一点点</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E7%9A%84%E5%8E%9F%E5%9B%A0win%E4%B8%8Amultprocessing%E5%92%8Clinux%E4%B8%8B%E7%9A%84multprocessing%E7%9A%84%E5%8C%BA%E5%88%AB-%E7%9B%B8%E5%BD%93%E4%BA%8E%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88windows%E4%B8%8B%E9%9C%80%E8%A6%81freeze-support"><span class="toc-number">1.</span> <span class="toc-text">还有一个非常重要的原因win上multprocessing和linux下的multprocessing的区别,相当于说为什么windows下需要freeze_support()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%BD%E4%BA%86%E6%89%AF%E4%BA%86%E4%B8%80%E5%A4%A7%E5%A0%86%E6%B2%A1%E6%9C%89%E7%94%A8%E7%9A%84%E8%A8%80%E5%BD%92%E6%AD%A3%E4%BC%A0"><span class="toc-number">1.1.</span> <span class="toc-text">好了扯了一大堆没有用的言归正传</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E6%9C%89%E5%A4%9A%E4%B8%AAsession%E5%91%A2%EF%BC%9F%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%BE%97%E5%88%B0pytest%E7%9A%84hook%E9%83%BD%E6%98%AFcall-fixture-func%E5%95%8A%E8%BF%99%E8%A6%81%E6%80%8E%E4%B9%88%E6%90%9E%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">session问题二：如果我有多个session呢？你看这代码，得到pytest的hook都是call_fixture_func啊这要怎么搞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E4%BC%9A%E5%87%BA%E7%8E%B0Cache%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F%E4%B8%8D%E8%A6%81%E6%85%8C%EF%BC%8C%E4%B8%8D%E6%98%AF%E5%9C%A8%E6%8A%A5%E9%94%99%E5%B0%B1%E6%98%AF%E5%9C%A8%E6%8A%A5%E9%94%99%E7%9A%84%E8%B7%AF%E4%B8%8A"><span class="toc-number">3.</span> <span class="toc-text">问题三：多进程下执行失败会出现Cache问题，如何解决呢？不要慌，不是在报错就是在报错的路上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9B%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E5%A4%9A%E4%B8%AAsession%E7%BA%A7%E5%88%AB%E7%9A%84fixtures%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E9%83%BD%E8%AF%B4%E4%BA%86%E4%B8%8D%E6%98%AF%E5%9C%A8%E6%8A%A5%E9%94%99%E5%B0%B1%E6%98%AF%E5%9C%A8%E6%8A%A5%E9%94%99%E7%9A%84%E8%B7%AF%E4%B8%8A"><span class="toc-number">4.</span> <span class="toc-text">问题四：多进程下多个session级别的fixtures文件之间互相调用问题，都说了不是在报错就是在报错的路上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%94%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E5%8F%8D%E5%B0%84%E6%97%A0%E6%B3%95%E7%94%9F%E6%95%88"><span class="toc-number">5.</span> <span class="toc-text">问题五：多进程下数据共享问题，会导致数据共享反射无法生效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8BAPI%E5%B1%82%E5%8D%95%E4%BE%8B%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">多进程下API层单例问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8BToken%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number"></span> <span class="toc-text">3、多进程下Token的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E8%BF%87%E6%85%A2%EF%BC%8C%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%B7%AE"><span class="toc-number"></span> <span class="toc-text">4、用例执行过慢，维护性差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%96%91%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%89%E6%8B%A9%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%A7%E5%AE%B6%E9%83%BD%E6%9C%89%E8%BF%99%E7%A7%8D%E7%96%91%E9%97%AE"><span class="toc-number">1.</span> <span class="toc-text">疑问：为什么要选择多进程，为什么不选择多线程呢？是不是大家都有这种疑问</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/30/%E8%AF%AD%E9%9B%80%E9%85%8D%E7%BD%AE%E9%92%89%E9%92%89%E5%92%8C%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1webhook/" title="语雀配置钉钉和企业微信webhook"><img src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="语雀配置钉钉和企业微信webhook"/></a><div class="content"><a class="title" href="/2021/09/30/%E8%AF%AD%E9%9B%80%E9%85%8D%E7%BD%AE%E9%92%89%E9%92%89%E5%92%8C%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1webhook/" title="语雀配置钉钉和企业微信webhook">语雀配置钉钉和企业微信webhook</a><time datetime="2021-09-30T02:52:53.000Z" title="发表于 2021-09-30 10:52:53">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/" title="自动化多进程下问题"><img src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动化多进程下问题"/></a><div class="content"><a class="title" href="/2021/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E9%97%AE%E9%A2%98/" title="自动化多进程下问题">自动化多进程下问题</a><time datetime="2021-09-27T03:53:30.000Z" title="发表于 2021-09-27 11:53:30">2021-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/" title="数据库乐观锁和悲观锁"><img src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库乐观锁和悲观锁"/></a><div class="content"><a class="title" href="/2021/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/" title="数据库乐观锁和悲观锁">数据库乐观锁和悲观锁</a><time datetime="2021-09-03T03:52:39.000Z" title="发表于 2021-09-03 11:52:39">2021-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/01/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" title="hexo+github搭建博客教程"><img src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo+github搭建博客教程"/></a><div class="content"><a class="title" href="/2021/09/01/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" title="hexo+github搭建博客教程">hexo+github搭建博客教程</a><time datetime="2021-09-01T02:43:01.000Z" title="发表于 2021-09-01 10:43:01">2021-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/30/%E8%A7%A3%E5%86%B3github-io%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E7%BB%8F%E5%8E%86/" title="解决github.io无法打开的经历"><img src="https://w.wallhaven.cc/full/j3/wallhaven-j3krk5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决github.io无法打开的经历"/></a><div class="content"><a class="title" href="/2021/08/30/%E8%A7%A3%E5%86%B3github-io%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E7%BB%8F%E5%8E%86/" title="解决github.io无法打开的经历">解决github.io无法打开的经历</a><time datetime="2021-08-30T06:13:31.000Z" title="发表于 2021-08-30 14:13:31">2021-08-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jack</div><div class="footer_custom_text">快来和我一起成长吧</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'KzLNARCro6AGOguEaBJQvwy0-gzGzoHsz',
      appKey: 'NrFmIQSBmxxijX6chW3bfifY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>